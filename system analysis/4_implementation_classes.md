Основные классы реализации (АТД) в проекте

Каких-то специфических структур данных я добавлять не планирую, но было бы правильным обернуть стандартные коллекции в проектные АТД, чтобы классы анализа реализовывали поведение, связанное с реальным миром (в данном случае - геймплей), а технические детали (работа со стандартными структурами данных, памятью) были инкапсулированы в отдельных типах. Также у этих типов будут недоступны "лишние" операции стандартных коллекций, доступ к которым нежелательно давать классам анализа.

1. TileMatrix - матрица из плиток, обертка над стандартным контейнером (в C++ - ```std::vector<std::vector<Tile>>```). В этом классе можно будет реализовать операции работы непосредственно с отдельными плитками в памяти (```swap``` и т.п.), этот интерфейс будет использоваться классом анализа ```Board```. А в самом ```Board``` реализовывать геймплейную логику.
1. Coordinates - пара индексов _(x, y)_, которыми задается клетка на доске/в матрице. Сами индексы также можно обернуть в объекты-значения Row и Column.
1. HistoryList - обертка над динамическим массивом, для представления истории ходов
1. SettingsTable - обертка над таблицей "настройка -> значение настройки".
1. BestScoreList - обертка над динамическим массивом рекордов